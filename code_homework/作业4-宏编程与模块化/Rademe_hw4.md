# Rademe_hw4

# 宏编程与模块化项目开发文档

项目源码地址：https://github.com/yyh2154064/Masm_8086.git

## 1.宏编程

### 1.1.宏编程与过程调用的不同

宏编程的过程其实与过程调用差不多，唯一的不同在于代码上：

- **宏编程中调用宏，相当于把宏定义的代码直接搬过来用，看上去主函数代码缩短，其实代码长度并没有发生改变（属于是开发者自己看着舒服）；**
- **过程调用则是真正意义上存在指令的跳转，有一个当前IP进栈，跳转执行，结束后IP出栈回到现场的过程（操作系统中保存现场的概念），也是实实在在地减少了主函数的代码行数。** 

### 1.2.宏编程的使用

在我最初完成的代码里，我是将过程调用的输入年月日并输出的那个项目拿来改，工作量非常小。我的四个过程：输入、打印年、月、日中均不存在参数的传递，也是在27号上午得知需要在宏调用的过程中加入参数的传递，所以我写了一个新的代码。大致功能如下：

- 打印提示信息
- 键盘输入0~9的数字
- 函数将数字翻三倍再输出

这里用到传参的是`Disp`函数，它将传入的寄存器的值翻三倍，然后存放在寄存器中。

### 1.3.过程中的问题

#### 1.3.1.传参

宏编程其实和过程调用差不多，但是在传参的过程中，我还是遇到了问题。

传入的寄存器似乎必须是16位，一个完整的寄存器，我今天在尝试传参的过程中采用 `Disp al`这种形式则会报错。除此之外代码完成地比较顺利。在传参的过程中，我只需要将参数想象成c语言中的函数参数即可，唯一不同的点在于我需要考虑寄存器的分配与使用。

#### 1.3.2.宏的位置

在过程调用里，我一般将过程放在主程序的最后，在主程序结束语句（调用int 21h中断）后写过程，最后是代码段结束。但在宏编程的过程中不是这样。因为过程调用是直接转跳到指定地点进行程序执行，所以无所谓顺序，但是宏的定义不同，这就相当于是我事先人为给宏定义一个名字，在程序执行的过程中，遇到这个名字后编译器知道应该往哪里找，但如果**宏定义出现在调用后面**，则找不到，会报错（程序是从上往下执行，宏编程不会发生跳转，当执行到调用的时候如果没有事先读到宏定义，则默认没有，就会报错）

所以i，我最终将宏定义放在文件开头，一目了然。

### 1.4.心得体会

从程序员的角度来看，其实宏编程和过程调用的写法都差不多，对我个人来说，更喜欢宏编程，将定义放在文件开头，比较方面查找与修改。而这二者都可以进行模块化编程。唯一需要注意的点在于宏不会减少主函数代码长度，但过程调用可以。



## 2.模块化编程

### 2.1.项目要求

将过程调用中的工资计算项目中主函数与功能函数分离，采用模块化编程的方式，用多个文件共同编译，最终链接后生成一个可执行文件。在这个过程中不用INCLUDE指令。

讲道理，我最开始做的时候确实INCLUDE大法，实现的过程和宏编程一摸一样。但这个项目存在的意义在于对于PUBLIC、EXTRN等指令的理解。

### 2.2.完成路径

我首先查阅了模块化编程中的注意事项。发现在网上大多数资源中对于模块化的介绍并不深刻细致。更多只是一带而过。但我在自己编程的过程中还是遇到了很多的问题。

起初我不知道该怎么处理，数据段如何共享？怎么进行过程的分离？如何编译？PUBLIC、EXTRN指令如何使用？放在哪里？最终，我还是从helloworld入手。

我首先让人工智能帮我将源代码分离，随后观察各种指令的处理方法，总结学习后开始进行代码修改，最终完成任务。

### 2.3.过程中的问题

#### 2.3.1.数据段的共享

我将数据段放在主程序中，然后在功能程序中共享，这里我采用了两种方式：

对于数据段中有定义局部变量名的，我采用如下方式共享：

```assembly
DATASEG SEGMENT
    EXTRN MSG:FAR  ; 引用 MSG 数据
DATASEG ENDS
```

对于像工资计算这样没有局部变量名的，我采用如下方式共享：

```assembly
codesg segment
	ASSUME CS:codesg
	PUBLIC transmit, Print
	EXTRN data:FAR
	EXTRN table:FAR
	EXTRN str:FAR
```

不单独写一个数据段，经过我的实践，两种方法都可以，为代码精简，我采用第二种。

#### 2.3.2.函数的公有化

采用PUBLIC函数，表示这个过程公有化，其他源程序可以在声明后随意调用。需要注意的是，由于是源程序与源程序之间的调用，这里的关键词取far，其中核心代码如下：

```ASM
	PUBLIC transmit, Print
	...
transmit proc far
	ret
transmit endp
```

需要注意的是，在公有化的过程中，仅仅只需要标注需要公有化的过程就可以了，在我的程序中，`transmit`过程还调用了别的过程，存在过程调用的嵌套，但由于嵌套的那个过程全程仅在这个文件中使用，因此不需要额外公有化，这样精准地公有化也可以在以后的大规模项目中保证代码的安全性。

#### 2.3.3.函数的调用

与2.3.2类似，函数在主程序中调用前，需要声明，这个过程是从外部来的，关键词取far，其中核心代码如下：

```ASM
	EXTRN transmit:FAR, Print:FAR
	...
	call transmit
```

#### 2.3.4.声明的位置

所有的声明都需要在代码段内部完成，对于附加的程序文件，也需要有一个完整的代码段。（这里我在第一次写的时候把这个文件理解为ｃ语言中的头文件，结果报错）。需要注意的是，对于最终写完的文件，需要保证每一个都是可以编译通过，生成ｏｂｊ文件的，最后再将他们链接起来即可。

### 2.4.心得体会

再最开始的时候我无从下手，现在我已经可以熟练地将一个源文件拆解再链接，我总结的步骤大致如下：

- 数据段共享（EXTRN data:FAR）
- 过程函数的封装（类似于上一次的过程调用作业）
- 过程函数公有化（PUBLIC）
- 主程序声明（EXTRN）